<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="C++新特性系列一：基础知识"><meta name="keywords" content="C++"><meta name="author" content="CinKate"><meta name="copyright" content="CinKate"><title>C++新特性系列一：基础知识 | CinKate's Blogs</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?b77222dd6b9929f160b8a04fc8705337";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '3.9.0'
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、auto"><span class="toc-number">1.</span> <span class="toc-text">一、auto</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、静态变量，指针和引用"><span class="toc-number">2.</span> <span class="toc-text">二、静态变量，指针和引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、左值、右值、左值引用、右值引用"><span class="toc-number">3.</span> <span class="toc-text">三、左值、右值、左值引用、右值引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四、move函数，临时对象"><span class="toc-number">4.</span> <span class="toc-text">四、move函数，临时对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#五、可调用对象"><span class="toc-number">5.</span> <span class="toc-text">五、可调用对象</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="http://imgsrc.baidu.com/forum/w%3D580/sign=f8de0e9b3e87e9504217f3642039531b/1c3bd133c895d143e395e57b77f082025baf0726.jpg"></div><div class="author-info__name text-center">CinKate</div><div class="author-info__description text-center">长笛一声人倚楼~</div><div class="follow-button"><a href="https://github.com/renxingkai">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">52</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">32</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">17</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(http://p17.qhimg.com/d/_open360/fengjing0403/21.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">CinKate's Blogs</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/about">About</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">C++新特性系列一：基础知识</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-08-16</time><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">3.4k</span><span class="post-meta__separator">|</span><span>Reading time: 13 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="一、auto"><a href="#一、auto" class="headerlink" title="一、auto"></a>一、auto</h2><ol>
<li><p>auto只能推断出类型，引用不是类型，所以auto无法推断出引用，要使用引用只能自己加引用符号。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">auto</span> i2 = i;  <span class="comment">// i2为int类型</span></span><br><span class="line">    <span class="keyword">auto</span> &amp;i2 = i; <span class="comment">// i2为int&amp;类型</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>auto关键字在<strong>推断引用的类型</strong>时：会直接将引用替换为引用指向的对象。其实引用一直是这样的，引用不是对象，任何使用引用的地方都可以直接替换成引用指向的对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int i = 100;</span><br><span class="line">    const int &amp;i2 = i;//此处i2类型为const int &amp;</span><br><span class="line">    auto i3 = i2;//i3类似是int，此处是：auto关键字在推断引用的类型时：会直接将引用替换为引用指向的对象。由于i2为引用类型，因此在auto推断时候，把i2替换为了该引用指向的对象</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>auto关键字在推断类型时，如果<strong>没有引用符号</strong>，会忽略值类型的const修饰，而保留修饰指向对象的const，典型的就是指针。可能有些不好理解，看看代码就好说了。3和4的主要作用对象就是指针。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    // example 1</span><br><span class="line">    int i = 100;</span><br><span class="line">    const int *const pi = &amp;i; //第一个const修饰指针指向的值，第二个const指向自己pi</span><br><span class="line">    // 3.没有引用符号，会忽略值类型的const修饰，而保留修饰指向对象的const</span><br><span class="line">    //因此把第二个const忽略了，保留了第一个const</span><br><span class="line">    auto pi2 = pi; // pi2为const int *</span><br><span class="line"></span><br><span class="line">    // example 2</span><br><span class="line">    const int i = 100; //由于此处的const修饰值，所以会被忽略</span><br><span class="line">    auto i2 = i;       //因此i2类型是int</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>auto关键字在推断类型时，如果有了引用符号，那么值类型的const和修饰指向对象的const都会保留。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    // example 1</span><br><span class="line">    int i = 100;</span><br><span class="line">    const int *const pi = &amp;i;</span><br><span class="line">    auto i2 = pi;  // i2类型为const int * 没有引用类型，忽略值类型修饰的const，保留修饰对象的const</span><br><span class="line">    auto &amp;i2 = pi; // i2类型为const int * const //有引用符号，值类型的const和修饰指向对象的const都会保留</span><br><span class="line">    // example 2</span><br><span class="line">    const int i = 100;</span><br><span class="line">    auto &amp;i2 = i; // i2类型为const int &amp;   //有引用符号，值类型的const和修饰指向对象的const都会保留</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>其实3，4为什么会出现这种情况，因为在传递值时，修改这个值并不会对原有的值造成影响。而传递引用时，修改这个值会直接对原有的值造成影响。</p>
<ol start="5">
<li><p>当然，我们可以在前面加上const，这样永远都有const的含义。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    // example 1</span><br><span class="line">    int i = 100;</span><br><span class="line">    const auto i2 = i; //i2类型为const int</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>auto不会影响编译速度，甚至会加快编译速度。因为编译器在处理XX a = b时，当XX是传统类型时，编译期需要检查b的类型是否可以转化为XX。当XX为auto时，编译期可以按照b的类型直接给定变量a的类型，所以效率相差不大，甚至反而还有提升。</p>
</li>
<li>（*）最重要的一点，就是auto不要滥用，对于一些自己不明确的地方不要乱用auto，否则很可能出现事与愿违的结果，使用类型应该安全为先。</li>
<li>（*）auto主要用在与模板相关的代码中，一些简单的变量使用模板常常导致可读性下降，经验不足还会导致安全性问题。</li>
</ol>
<h2 id="二、静态变量，指针和引用"><a href="#二、静态变量，指针和引用" class="headerlink" title="二、静态变量，指针和引用"></a>二、静态变量，指针和引用</h2><p>变量的存储位置有三种，分别是静态变量区，栈区，堆区。<br>静态变量区在编译时就已经确定地址，存储全局变量与静态变量。<br><img src="https://rxk-1300064984.cos.ap-nanjing.myqcloud.com/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220806231205.png" alt><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">unsigned g_i = 0; //全局变量在程序编译时已经初始化了</span><br><span class="line">unsigned test()</span><br><span class="line">&#123;</span><br><span class="line">    static unsigned callCount = 0;//程序编译时候，已经被赋值为0了，在程序执行时，直接执行了下一行</span><br><span class="line">    return ++callCount;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    ++g_i; //程序运行时才执行，所以没问题</span><br><span class="line">    test();</span><br><span class="line">    test();</span><br><span class="line">    test();</span><br><span class="line">    test();</span><br><span class="line">    test();</span><br><span class="line">    unsigned testFuncCallNum = test();</span><br><span class="line">    std::cout &lt;&lt; testFuncCallNum; //6</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>指针都是存储在栈上或堆上，不管在栈上还是堆上，都一定有一个地址。</p>
<p>本质上说，指针和普通变量没有区别。</p>
<p>在32位系统中，int变量和指针都是32位。指针必须和“&amp;”，“*”这两个符号一起使用才有意义。</p>
<p>&amp;a代表的a这个变量的地址，a代表的a对应地址存储的值，*a代表对应地址存储的值作为地址对应的值。</p>
<p>所以指针才可以灵活的操作内存，但这也带来了严重的副作用，比如指针加加减减就可以操作内存，所以引用被发明了，引用就是作用阉割的指针（可以视为“类型*const”，<strong>所以引用必须上来就赋初值，不能设置为空），编译器不将其视作对象，操作引用相当于操作引用指向的对象。也就从根本是杜绝了引用篡改内存的能力。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int i = 100;</span><br><span class="line">    int &amp;i2 = i;</span><br><span class="line">    int const *i3 = &amp;i; //以上两行本质上一样</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新手如果不懂内存，就直接将引用视为指向对象的别名就可以了。</p>
<h2 id="三、左值、右值、左值引用、右值引用"><a href="#三、左值、右值、左值引用、右值引用" class="headerlink" title="三、左值、右值、左值引用、右值引用"></a>三、左值、右值、左值引用、右值引用</h2><p>1.左右值</p>
<p>C++任何一个对象要么是左值，要么是右值。</p>
<p>比如int i = 10，i和10都是对象</p>
<p><strong>左值：</strong> 拥有地址属性的对象就叫左值，左值来源于c语言的说法，能放在“=”左面的就是左值，注意，左值也可以放在“=”右面。</p>
<p><strong>右值：</strong> 不是左值的对象就是右值。或者说无法操作地址的对象就叫做右值。一般来说，判断一个对象是否为右值，就看它是不是左值，有没有地址属性，不是左值，那就是右值。</p>
<p>比如临时对象，就都是右值，临时对象的地址属性无法使用。</p>
<p>注意：左值也可以放在“=”右面，但右值绝对不可以放在等号左面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int i = 100;//i是左值</span><br><span class="line">    int i2=i;// i2、i都是左值</span><br><span class="line">    </span><br><span class="line">    int i3=(i+1);//(i+1)是临时对象，有地址，但是无法使用，因此是右值</span><br><span class="line"></span><br><span class="line">    ++i=200;//左值,先给i+1，返回i,有地址属性，可以操作地址</span><br><span class="line">    // i++=200;//错误,返回的值是(i+1)此处的i是临时变量，无法使用地址属性</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>引用的分类</li>
</ol>
<p>(1)    普通左值引用：就是一个对象的别名，只能绑定左值，无法绑定常量对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int i = 100;//i是左值</span><br><span class="line">    int &amp;ref=i;//普通左值引用</span><br><span class="line"></span><br><span class="line">    const int i = 100;//i是左值</span><br><span class="line">    int &amp;ref=i;//报错,error</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(2)    const左值引用：可以对常量起别名，可以绑定左值和右值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    const int i = 100; // i是左值</span><br><span class="line"></span><br><span class="line">    const int &amp;ref = i; //const左值引用,可以对常量起别名，可以绑定左值或者右值</span><br><span class="line">    std::cout&lt;&lt;ref&lt;&lt;std::endl;</span><br><span class="line">    const int &amp;ref3 = (i+1);</span><br><span class="line">    std::cout&lt;&lt;ref3&lt;&lt;std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(3)    右值引用：只能绑定右值的引用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int i = 100; // i是左值</span><br><span class="line">    int &amp;&amp;rrefI = 200;</span><br><span class="line">    int &amp;&amp;rrefI = (i + 1);</span><br><span class="line">    int &amp;&amp;rrefI = i++;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(4)    万能引用。</p>
<h2 id="四、move函数，临时对象"><a href="#四、move函数，临时对象" class="headerlink" title="四、move函数，临时对象"></a>四、move函数，临时对象</h2><ol>
<li>move函数：</li>
</ol>
<p>(1)    右值看重对象的值而不考虑地址，move函数可以对一个左值使用，使操作系统不再在意其地址属性，将其完全视作一个右值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int i = 100;                // i是左值</span><br><span class="line">    int &amp;&amp;rrefI = i;            //错误</span><br><span class="line">    int &amp;&amp;rrefI = std::move(i); //正确</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(2)    move函数让操作的对象失去了地址属性，所以我们有义务保证以后不再使用该变量的地址属性，简单来说就是不再使用该变量，因为左值对象的地址是其使用时无法绕过的属性。</p>
<ol start="2">
<li>临时对象：</li>
</ol>
<p>右值都是不体现地址的对象。那么，还有什么能比临时对象更加没有地址属性呢？右值引用主要负责处理的就是临时对象。</p>
<p><strong>程序执行时生成的中间对象就是临时对象，注意，所有的临时对象都是右值对象，因为临时对象产生后很快就可能被销毁，使用的是它的值属性。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">int get_i()</span><br><span class="line">&#123;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int i = 100;         // i是左值</span><br><span class="line">    int &amp;&amp;rrefI = i + 1; //临时对象-&gt;右值</span><br><span class="line">    int &amp;&amp;rreg = get_i(); //临时对象-&gt;右值</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="五、可调用对象"><a href="#五、可调用对象" class="headerlink" title="五、可调用对象"></a>五、可调用对象</h2><p>如果一个对象可以使用调用运算符“()”，()里面可以放参数，这个对象就是可调用对象。<br>（*）注意：可调用对象的概念新手只要记住就可以了，后面会反复用到，这个概念很重要。<br>可调用对象的分类：</p>
<ol>
<li>函数：</li>
</ol>
<p>函数自然可以调用()运算符，是最典型的可调用对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">void get_i()</span><br><span class="line">&#123;</span><br><span class="line">    std::cout&lt;&lt;&quot;123&quot;&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    get_i();//get_i就是可调用对象，()为运算符</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">void get_i(int i)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; &quot;123&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">using pf_type = void (*)(int); //函数指针</span><br><span class="line"></span><br><span class="line">void myFunc(pf_type pf, int i)</span><br><span class="line">&#123;</span><br><span class="line">    pf(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    myFunc(get_i, 200); // </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>仿函数：</li>
</ol>
<p>具有operator()函数的类对象，此时类对象可以当做函数使用，因此称为仿函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">class Test</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void operator()(int i)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; &quot; void operator()(int i)&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Test t;</span><br><span class="line">    t(20); //可调用对象</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>lambda表达式：</li>
</ol>
<p>就是匿名函数，普通的函数在使用前需要找个地方将这个函数定义，于是C++提供了lambda表达式，需要函数时直接在需要的地方写一个lambda表达式，省去了定义函数的过程，增加开发效率。</p>
<p>注意：lambda表达式很重要，现代C++程序中，lambda表达式是大量使用的。</p>
<p>lambda表达式的格式：最少是“[] {}”，完整的格式为“[] () -&gt;ret {}”。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    []</span><br><span class="line">    &#123; std::cout &lt;&lt; &quot; void operator()(int i)&quot; &lt;&lt; std::endl; &#125;();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>lambda各个组件介绍</p>
<ol>
<li>[]代表捕获列表：表示lambda表达式可以访问前文的哪些变量。</li>
</ol>
<ul>
<li>[]表示不捕获任何变量。</li>
<li>[=]：表示按值捕获所有变量。</li>
<li>[&amp;]：表示按照引用捕获所有变量。<br>=，&amp;也可以混合使用，比如</li>
<li>[=, &amp;i]：表示变量i用引用传递，除i的所有变量用值传递。</li>
<li>[&amp;, i]：表示变量i用值传递，除i的所有变量用引用传递。<br>当然，也可以捕获单独的变量</li>
<li>[i]：表示以值传递的形式捕获i</li>
<li>[&amp;i]：表示以引用传递的方式捕获i</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int i = 10;</span><br><span class="line">    //[]为空表示不捕获，[=]表示捕获所有变量</span><br><span class="line">    [=]</span><br><span class="line">    &#123; </span><br><span class="line">        std::cout&lt;&lt;i&lt;&lt;std::endl;</span><br><span class="line">        std::cout &lt;&lt; &quot; void operator()(int i)&quot; &lt;&lt; std::endl; &#125;();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>()代表lambda表达式的参数，函数有参数，lambda自然也有。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int i = 10;</span><br><span class="line">    //[]为空表示不捕获，[=]表示捕获所有变量</span><br><span class="line">    [=](int element) // element函数参数</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; element &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; &quot;void operator()(int i)&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125;(200); //给函数参数element的值</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>-&gt;ret表示指定lambda的返回值，如果不指定，lambda表达式也会推断出一个返回值的。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int i = 10;</span><br><span class="line">    //[]为空表示不捕获，[=]表示捕获所有变量</span><br><span class="line">    // element函数参数</span><br><span class="line">    auto ret = [=](int element) -&gt; int </span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; element &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; &quot;void operator()(int i)&quot; &lt;&lt; std::endl;</span><br><span class="line">        return i;</span><br><span class="line">    &#125;(200); //给函数参数element的值</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>{}就是函数体了，和普通函数的函数体功能完全相同。</li>
</ol>
<p><strong>lambda表达式最常见用法 为 给普通函数 作参数。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using pf_type = void (*)(int); //函数指针</span><br><span class="line"></span><br><span class="line">void myFunc(pf_type pf, int i)</span><br><span class="line">&#123;</span><br><span class="line">    pf(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    myFunc([](int i)</span><br><span class="line">           &#123;</span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; &quot;void operator()(int i)&quot; &lt;&lt; std::endl; &#125;,</span><br><span class="line">           200);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果需要捕获 lambda中的参数，需要以下方法修改:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;functional&gt;</span><br><span class="line"></span><br><span class="line">using pf_type = void (*)(int); //函数指针</span><br><span class="line">using func_type = std::function&lt;void(int)&gt;;</span><br><span class="line"></span><br><span class="line">void myFunc(pf_type pf, int i)</span><br><span class="line">&#123;</span><br><span class="line">    pf(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void myFunc1(func_type pf, int i)</span><br><span class="line">&#123;</span><br><span class="line">    pf(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int i1 = 100;</span><br><span class="line">    //以下报错，函数指针的缺陷，无法捕获</span><br><span class="line">    myFunc([i1](int i)</span><br><span class="line">           &#123;</span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; i1 &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; &quot;void operator()(int i)&quot; &lt;&lt; std::endl; &#125;,</span><br><span class="line">           200);</span><br><span class="line">    //c++11 提供了functional，解决以上问题</span><br><span class="line">    myFunc1([i1](int i)</span><br><span class="line">           &#123;</span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; i1 &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; &quot;void operator()(int i)&quot; &lt;&lt; std::endl; &#125;,</span><br><span class="line">           200);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C++的可调用对象主要就这三个，当然，这三个也可以衍生出很多写法。</p>
<p>最常见的就是函数指针，函数指针的本质就是利用指针调用函数，本质还是函数。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">CinKate</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://renxingkai.github.io/2022/08/17/cpp-base/">http://renxingkai.github.io/2022/08/17/cpp-base/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a></div><div class="social-share pull-right" data-disabled="google,facebook"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2022/08/21/cpp-object/"><i class="fa fa-chevron-left">  </i><span>C++新特性系列二：类与对象</span></a></div><div class="next-post pull-right"><a href="/2022/07/14/deeprec/"><span>推荐系统排序模型-从LR到XXXX</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(http://p17.qhimg.com/d/_open360/fengjing0403/21.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2022 By CinKate</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://renxingkai.github.io">blog</a>!</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script src="/js/katex.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>