<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="C++新特性系列四：STL"><meta name="keywords" content="C++"><meta name="author" content="CinKate"><meta name="copyright" content="CinKate"><title>C++新特性系列四：STL | CinKate's Blogs</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?b77222dd6b9929f160b8a04fc8705337";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '3.9.0'
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、stl介绍与6大模块介绍"><span class="toc-number">1.</span> <span class="toc-text">一、stl介绍与6大模块介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、容器"><span class="toc-number">2.</span> <span class="toc-text">二、容器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、迭代器"><span class="toc-number">3.</span> <span class="toc-text">三、迭代器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四、算法"><span class="toc-number">4.</span> <span class="toc-text">四、算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#五、仿函数"><span class="toc-number">5.</span> <span class="toc-text">五、仿函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#六、适配器与分配器"><span class="toc-number">6.</span> <span class="toc-text">六、适配器与分配器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#附录：-STL各种容器的操作"><span class="toc-number">7.</span> <span class="toc-text">附录： STL各种容器的操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-vector的各种函数"><span class="toc-number">7.1.</span> <span class="toc-text">1. vector的各种函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-构造函数"><span class="toc-number">7.1.1.</span> <span class="toc-text">1.构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-增加函数"><span class="toc-number">7.1.2.</span> <span class="toc-text">2. 增加函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-删除函数"><span class="toc-number">7.1.3.</span> <span class="toc-text">3. 删除函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-遍历函数"><span class="toc-number">7.1.4.</span> <span class="toc-text">4. 遍历函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-判断函数"><span class="toc-number">7.1.5.</span> <span class="toc-text">5. 判断函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-大小函数"><span class="toc-number">7.1.6.</span> <span class="toc-text">6. 大小函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-其它函数"><span class="toc-number">7.1.7.</span> <span class="toc-text">7. 其它函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-deque的各种函数："><span class="toc-number">7.2.</span> <span class="toc-text">2. deque的各种函数：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-list的各种函数"><span class="toc-number">7.3.</span> <span class="toc-text">3. list的各种函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-string的各种函数"><span class="toc-number">7.4.</span> <span class="toc-text">4. string的各种函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-forward-list"><span class="toc-number">7.5.</span> <span class="toc-text">5. forward_list:</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="http://imgsrc.baidu.com/forum/w%3D580/sign=f8de0e9b3e87e9504217f3642039531b/1c3bd133c895d143e395e57b77f082025baf0726.jpg"></div><div class="author-info__name text-center">CinKate</div><div class="author-info__description text-center">长笛一声人倚楼~</div><div class="follow-button"><a href="https://github.com/renxingkai">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">53</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">33</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">17</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(http://p17.qhimg.com/d/_open360/fengjing0403/21.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">CinKate's Blogs</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/about">About</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">C++新特性系列四：STL</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-08-28</time><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">7.1k</span><span class="post-meta__separator">|</span><span>Reading time: 29 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p><strong>微软STL官方开发文档<a href="https://docs.microsoft.com/zh-cn/cpp/dotnet/stl-clr-library-reference?view=msvc-170" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/cpp/dotnet/stl-clr-library-reference?view=msvc-170</a></strong></p>
<h2 id="一、stl介绍与6大模块介绍"><a href="#一、stl介绍与6大模块介绍" class="headerlink" title="一、stl介绍与6大模块介绍"></a>一、stl介绍与6大模块介绍</h2><ol>
<li>stl的介绍：</li>
</ol>
<ul>
<li>stl就是（standard template library）的简称，定义在std命名空间中，定义了C++常用的容器与算法等。</li>
<li>泛型编程的概念：用模板进行编程，可以实现一些其它方式难以实现的功能，但对于新手来说，泛型编程可能会难以理解，摸不着头脑。<br>也就是说，模板是学习泛型编程的基础。<br>注意：泛型编程不属于面向对象编程的范畴，泛型编程和面向对象编程是并列的。</li>
<li>stl作为泛型编程的最典型代表，它实现了其它编程方式难以实现的效果，比如将整个模板库分为六个部分，每个部分可以单独设计。举个最简单的例子，vector和map在数据结构方面完全不一样，但stl可以设计出“迭代器”这个模块，让该模块可以在不同的数据结构中按照同样的方式运行。这种技术没有泛型编程是难以实现的。</li>
</ul>
<ol start="2">
<li>学习stl的注意事项</li>
</ol>
<ul>
<li>学习stl一定要有全局观念，不要局限于单个容器，重点在于明白六大组件之间的联系。</li>
<li>当然，如果只是单纯为了应付当前的业务，单独学一下某个容器的用法也没有问题。</li>
</ul>
<ol start="3">
<li>SLT的六大容器介绍：</li>
</ol>
<ul>
<li>容器（container）：是一种数据结构，也就是真正用来存储数据的地方。分为三类<ul>
<li>顺序式容器：</li>
<li>关联式容器：</li>
<li>无序式容器：其实无序式容器也是一种关联式容器，但是既然C++标准委员会将无序容器与关联式容器平行的列了出来，那么我们这里也就让无序式容器和关联式容器平行吧。</li>
</ul>
</li>
<li>迭代器（iterator）：提供了可以访问任何容器的方法。</li>
<li>算法（alogorithm）：用来操作容器中的数据的模板函数。</li>
<li>仿函数（functor）</li>
<li>适配器（adaptor）</li>
<li>分配器（allocator）</li>
</ul>
<h2 id="二、容器"><a href="#二、容器" class="headerlink" title="二、容器"></a>二、容器</h2><p><strong>1. 顺序容器</strong></p>
<p>顺序容器（sequence container）：每个元素都有固定的位置，位置取决于插入时间和地点，与元素的值无关</p>
<ul>
<li>vector：将元素置于一个动态数组中，可以随机存储元素（也就是用索引直接存取）。</li>
</ul>
<p>数组尾部添加或删除元素非常迅速。但在中部或头部就比较费时。</p>
<ul>
<li>deque：“double end queue”的缩写，也就是双端队列。deque的实现相比于vector有些复杂，但本质仍然是优化过的动态数组，只不过相比于单纯的动态数组，在前面添加或删除元素非常快了。<ul>
<li>可以随机存储元素。头部和尾部添加或删除元素都非常快（略慢与vector）。但在    中间插入元素比较费时（和vector差不多）。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    std::deque&lt;int&gt; ideque&#123;1, 2, 3, 4&#125;;</span><br><span class="line">    ideque.push_front(1); //在前面添加元素</span><br><span class="line">    ideque.pop_front();   //在前面删除元素</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>list：本质就是链表，所以自然具有了链表的属性。<ul>
<li>不能随机存取元素（也就是list无法用索引存取元素）。在任何位置插入和删除元    素都比较迅速。（在任何位置插入删除元素的时间相同，在元素头部操作慢于deque，在元素尾部操作慢于deque和vector）</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include&lt;list&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    std::deque&lt;int&gt; ideque&#123;1, 2, 3, 4&#125;;</span><br><span class="line">    std::list&lt;int&gt; iList&#123;1,2,3,4,5&#125;;</span><br><span class="line">    iList.push_back(1);</span><br><span class="line">    iList.push_front(1);</span><br><span class="line">    iList.insert(++iList.begin(),1);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>string：没什么好说的，就是把普通字符串封装了一下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include&lt;list&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    const char *str=&quot;hello world&quot;;</span><br><span class="line">    std::string st1(&quot;1111&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>forward_list：单项链表，简单来说就是受限的list，凡是list不支持的功能，它都不支持。做各种支持的操作效率都会高于list，最典型的就排序算法了，forword_list要优于list。</p>
<ul>
<li>ForwordList 只提供前向迭代器，而不是双向迭代器。因此它也不支持反向迭代器。</li>
<li>ForwordList不提供成员函数 size()。</li>
<li>ForwordList 没有指向最末元素的锚点。基于这个原因，不提供用以处理最末元素的成员 back(),push_back(),pop_back()。</li>
</ul>
</li>
</ul>
<p><strong>2. 关联容器</strong></p>
<p> 关联容器（associated container）：元素位置取决于元素的值，和插入顺序无关。</p>
<ul>
<li>set/multiset：使用“红黑树”实现，是一种高度平衡的二叉树，二叉树的本质决定了set/multiset的元素存取值取决于元素本身的值，和插入顺序无关。</li>
</ul>
<p>内部元素的值依据元素的值自动排列，与插入顺序无关。set内部相同数值的元素只能出现一次，multiset内部相同数值的元素可出现多次。容器用二叉树实现，便于查找。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    std::set&lt;int&gt; iset&#123;1, 3, 4, 5, 4, 4, 5&#125;;</span><br><span class="line">    for (auto i : iset)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    std::multiset&lt;int&gt; imultiset&#123;1, 3, 4, 5, 4, 4, 5&#125;;</span><br><span class="line">    for (auto i : imultiset)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>map/multimap：使用“红黑树”实现，是一种高度平衡的二叉树。</li>
</ul>
<p>内部元素是成对的“key/value”，也就是“键值/实值”，内部元素依据其键值自动排序，map内部相同的键值只能出现一次，multimap则可以出现多次。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    std::map&lt;int, std::string&gt; map1;</span><br><span class="line">    map1.insert(std::pair&lt;int, std::string&gt;(1, &quot;111&quot;));</span><br><span class="line">    map1.insert(std::pair&lt;int, std::string&gt;(2, &quot;222&quot;));</span><br><span class="line">    map1.insert(std::pair&lt;int, std::string&gt;(3, &quot;333&quot;));</span><br><span class="line">    map1.insert(std::pair&lt;int, std::string&gt;(4, &quot;555&quot;));</span><br><span class="line">    for (auto const &amp;elem : map1)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; elem.first &lt;&lt; &quot;:&quot; &lt;&lt; elem.second &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    std::multiset&lt;int&gt; imultiset&#123;1, 3, 4, 5, 4, 4, 5&#125;;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3. 无序式容器（unordered container）</strong></p>
<p>(1)    unordered_map/unordered_multimap：使用“哈希表”实现的，由于哈希表的特性，实现了真正的无序。如果不理解为什么使用“哈希表”就是真正无序的，可以去百度一下“哈希表”，或者干脆直接记住就可以了。</p>
<p>使用方法也是“key/value”，和map/multimap类似。</p>
<p>(2)    unordered_set/unorder_multiset：同样使用“哈希表”实现的。自然具有了哈希表实现的容器的特点。</p>
<p>使用方法和setl/multiset类似。</p>
<p><strong>4. 关联式容器和无序式容器的对比：</strong></p>
<ul>
<li>关联式容器都是有序的，对于那些对顺序有要求的操作，关联式容器效率会高很多。（比如增加元素，删除元素）</li>
<li>无序容器都是真正的无序，在查找数据方面有着优势。（比如修改特定元素，查找元素）</li>
<li>从内存消耗的角度讲，无序容器要高于关联容器不过这并不重要。</li>
</ul>
<p>一句话来说，如果从这两类容器中选一个使用的话。如果是增加，删除元素比较频繁，就使用关联式容器。如果修改元素，查找元素比较平凡，就使用无序容器。</p>
<p><strong>5. 我们在处理数据时应该选择什么容器呢？</strong></p>
<ul>
<li>在我们需要使用存储“key/value”的容器时，只能使用map/multimap/unoredered_map/unordered_multimap。如果增加删除频繁，就使用map/multimap，修改，查找频繁，就使用unordered_map/unoredered_multimap。</li>
</ul>
<p>在真正的大型项目中，常常会对这两种容器进行测试，普通练习靠感觉就可以了</p>
<ul>
<li><p>在处理普通元素：</p>
<ul>
<li><p>当元素需要频繁插入删除时，选择顺序容器。</p>
<ul>
<li>如果在尾部插入删除，选择vector</li>
<li>在头部，尾部插入删除，选择deque</li>
<li>在中间插入，删除，选择list</li>
</ul>
</li>
<li><p>当元素需要频繁查找时，选择.set/multiset/unorder_set/unorder_multiset。</p>
<ul>
<li>频繁增加，删除时，选set，</li>
<li>频繁查找，修改时，选ordered_set</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>我们发现，对于普通元素，容器的选择不怎么容易判断。<br>其实在真正的大型项目中，要对各种容器进行测试的，普通练习一般选择vector或set就可以了。这两个使用是比较频繁的，</p>
<h2 id="三、迭代器"><a href="#三、迭代器" class="headerlink" title="三、迭代器"></a>三、迭代器</h2><ol>
<li><p>迭代器介绍：迭代器提供了一种可以顺序访问容器各个元素的方法，可以让我们无视不同容器存储方式的不同，用同一的方式访问数据。经过前面对容器的学习，相信大家已经体会到这一点了。</p>
</li>
<li><p>迭代器的作用：能够让迭代器与容器，算法在设计，使用时互不干扰，又能无缝耦合起来。使用迭代器可以灵活操作各种容器算法，而不需要考虑不同容器间的差异。</p>
</li>
</ol>
<h2 id="四、算法"><a href="#四、算法" class="headerlink" title="四、算法"></a>四、算法</h2><ol>
<li>stl的算法可以分为九个种类，具体有什么已经在“附录一”中完全列举了。</li>
</ol>
<ul>
<li>查找算法：</li>
<li>排序算法：</li>
<li>删除和替换算法：</li>
<li>排列组合算法：</li>
<li>算数算法：</li>
<li>生成和异变算法：</li>
<li>关系算法：</li>
<li>集合算法：</li>
<li>堆算法：</li>
</ul>
<ol>
<li>查找算法(13个)：判断容器中是否包含某个值</li>
</ol>
<ul>
<li>adjacent_find:<br>在iterator对标识元素范围内，查找一对相邻重复元素，找到则返回指向这对元素的第一个元素forwardIterator。否则返回最后一个元素的forwardIterator。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    std::vector&lt;int&gt; ivec&#123;1, 2, 3, 4, 5, 56, 6&#125;;</span><br><span class="line">    auto iter = std::adjacent_find(ivec.cbegin(), ivec.cend()); //查找相邻元素(默认两个元素连续相等)，返回迭代器</span><br><span class="line">    auto iter2 = std::adjacent_find(ivec.cbegin(), ivec.cend(), [](int elme1, int elme2)</span><br><span class="line">                                    &#123; return elme1 &gt;= 4 &amp;&amp; elme2 &gt;= 4; &#125;);//两个元素均&gt;=4 </span><br><span class="line">    if (iter == ivec.cend())</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;container don&apos;t have adjacent element&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; std::distance(ivec.cbegin(), iter) &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; &quot;container  have adjacent element&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>binary_search:<br>在有序序列中查找value，找到返回true。重载的版本实用指定的比较函数对象或函数指针来判断相等。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    std::vector&lt;int&gt; ivec&#123;1, 2, 3, 4, 5, 56, 6&#125;;</span><br><span class="line">    std::sort(ivec.cbegin(), ivec.cend(), [](int elem1, int elem2)</span><br><span class="line">              &#123; return elem1 &gt; elem2; &#125;);</span><br><span class="line">    //二分查找，存在返回true，不存在返回false</span><br><span class="line">    auto item = std::binary_search(ivec.cbegin(), ivec.cend(), 3, [](int elem1, int elem2)</span><br><span class="line">                                   &#123; return elem1 &gt; elem2; &#125;);//均为&gt;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>count:<br>利用等于操作符，把标志范围内的元素与输入值比较，返回相等元素个数。</li>
<li>count_if:<br>利用输入的操作符，对标志范围内的元素进行操作，返回结果为true的个数。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    std::vector&lt;int&gt; ivec&#123;1, 2, 3, 4, 5, 56, 6&#125;;</span><br><span class="line">    std::cout &lt;&lt; std::count(ivec.cbegin(), ivec.cend(), 4) &lt;&lt; std::endl;</span><br><span class="line">    //统计大于4的元素个数</span><br><span class="line">    std::cout &lt;&lt; std::count(ivec.cbegin(), ivec.cend(), [](int elem)</span><br><span class="line">                            &#123; return elem &gt; 4; &#125;)</span><br><span class="line">              &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>equal_range:<br>注意，必须对有序容器进查找，下面的lower_bound和upper_bound也是同理。<br>   功能类似equal，返回一对iterator，第一个表示lower_bound，第二个表示upper_bound。</li>
<li>find利用底层元素的等于操作符，对指定范围内的元素与输入值进行比较。当匹配时，结束搜索，返回该元素的一个InputIterator。</li>
<li><p>find_end:<br>在指定范围内查找”由输入的另外一对iterator标志的第二个序列”的最后一次出现。找到则返回最后一对的第一个迭代器，否则返回输入的”另外一对”的第一个迭代器。重载版本使用用户输入的操作符代替等于操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    std::vector&lt;int&gt; ivec1&#123;4, 5&#125;;</span><br><span class="line">    std::vector&lt;int&gt; ivec&#123;1, 2, 3, 4, 5, 56, 6, 2, 1, 3, 4, 5, 6, 6&#125;;</span><br><span class="line">    auto iter = std::find_end(ivec.cbegin(), ivec.cend(), ivec1.cbegin(), ivec1.cend());</span><br><span class="line">    std::cout &lt;&lt; std::distance(ivec.cbegin(), iter)</span><br><span class="line">              &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>find_first_of:<br>   在指定范围内查找”由输入的另外一对iterator标志的第二个序列”中任意一个元素的第一次出现。重载版本中使用了用户自定义操作符。</p>
</li>
<li>find_if:<pre><code>使用输入的函数代替等于操作符执行find。
</code></pre></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    std::vector&lt;int&gt; ivec1&#123;4, 5&#125;;</span><br><span class="line">    std::vector&lt;int&gt; ivec&#123;1, 2, 3, 4, 5, 56, 6, 2, 1, 3, 4, 5, 6, 6&#125;;</span><br><span class="line">    //第一次出现 vec位置</span><br><span class="line">    auto iter = std::find_first_of(ivec.cbegin(), ivec.cend(), ivec1.cbegin(), ivec1.cend());</span><br><span class="line">    std::cout &lt;&lt; std::distance(ivec.cbegin(), iter)</span><br><span class="line">              &lt;&lt; std::endl;</span><br><span class="line">    auto iter2 = std::find_if(ivec.cbegin(), ivec.cend(), [](int elem)</span><br><span class="line">                              &#123; return elem &amp;&amp; elem % 2; &#125;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>lower_bound:<br> 返回一个iterator，指向在有序序列范围内的可以插入指定值而不破坏容器顺序的第一个位置。重载函数使用自定义比较操作。</li>
<li>upper_bound:<br>返回一个iterator，指向在有序序列范围内插入value而不破坏容器顺序的最后一个位置，该位置标志一个大于value的值。重载函数使用自定义比较操作。</li>
<li>search:<br>这两个是真的不好描述，去微软官网查看一下吧，简单，比我在这里总结的强多了。</li>
<li>search_n:</li>
</ul>
<ol start="2">
<li>排序和通用算法(14个)：提供元素排序策略<br>inplace_merge:<br>merge:<br>nth_element:<br>partial_sort:<br>partial_sort_copy:<br>partition:<br>random_shuffle:<br>reverse:<br>reverse_copy:<br>rotate:<br>rotate_copy:<br>sort:<br>stable_sort:<br>stable_partition:</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    //merge</span><br><span class="line">    std::vector&lt;int&gt; ivec1&#123;4, 5&#125;;</span><br><span class="line">    std::vector&lt;int&gt; ivec&#123;1, 2, 3, 4, 5, 56, 6, 2, 1, 3, 4, 5, 6, 6&#125;;</span><br><span class="line">    std::vector&lt;int&gt; ivec_merge;</span><br><span class="line">    std::sort(ivec1.cbegin(), ivec1.cend());</span><br><span class="line">    std::sort(ivec.cbegin(), ivec.cend());</span><br><span class="line">    std::merge(ivec1.cbegin(), ivec1.cend(), ivec.cbegin(), ivec.cend(), ivec_merge.begin());</span><br><span class="line">    for (auto item : ivec_merge)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //随机打乱</span><br><span class="line">    std::random_shuffle(ivec1.cbegin(), ivec1.cend());</span><br><span class="line">    for (auto item : ivec1)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; item;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>删除算法(15个)<br>copy:<br>copy_backward:<br>iter_swap:<br>remove:<br>remove_copy:<br>remove_if:<br>remove_copy_if:<br>replace:<br>replace_copy:<br>replace_if:<br>replace_copy_if:<br>swap:<br>swap_range:<br>unique:<br>unique_copy:</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    std::vector&lt;int&gt; ivec1&#123;4, 5&#125;;</span><br><span class="line">    std::vector&lt;int&gt; ivec&#123;1, 2, 3, 4, 5, 56, 6, 2, 1, 3, 4, 5, 6, 6&#125;;</span><br><span class="line">    std::remove(ivec1.cbegin(), ivec1.cend(), 3); //删除</span><br><span class="line">    std::unique(ivec1.cbegin(), ivec1.cend(), 3); //将3放在最后位置</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>排列组合算法(2个)：提供计算给定集合按一定顺序的所有可能排列组合<br>next_permutation:<br>prev_permutation:</li>
<li>算术算法(4个)<br>accumulate:<br>partial_sum:<br>inner_product:<br>adjacent_difference:</li>
<li>生成和异变算法(6个)<br>fill:<br>fill_n:<br>for_each:<br>generate:<br>generate_n:<br>transform:</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    std::vector&lt;int&gt; ivec1&#123;4, 5&#125;;</span><br><span class="line">    std::vector&lt;int&gt; ivec&#123;1, 2, 3, 4, 5, 56, 6, 2, 1, 3, 4, 5, 6, 6&#125;;</span><br><span class="line">    std::for_each(ivec1.cbegin(), ivec1.cend(), [](int ele)</span><br><span class="line">                  &#123; return ele + 1; &#125;);//对每个元素进行+1</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="7">
<li>关系算法(8个)<br>equal:<br>includes:<br>lexicographical_compare:<br>max:<br>max_element:<br>min:<br>min_element:<br>mismatch:</li>
<li>集合算法(4个)<br>set_union:<br>set_intersection:<br>set_difference:<br>set_symmetric_difference:</li>
<li>堆算法(4个)<br>make_heap:<br>pop_heap:<br>push_heap:<br>sort_heap:</li>
</ol>
<h2 id="五、仿函数"><a href="#五、仿函数" class="headerlink" title="五、仿函数"></a>五、仿函数</h2><ol>
<li>仿函数定义：就是一个可以调用“()”运算符的类对象，将operator()重载的类的对象就是仿函数。</li>
</ol>
<p>简单来说，就是我们在用算法时最后一个参数需要一个可调用对象，stl本身已经帮我们定义了很多可调用对象，不用我们自己再去定义了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    std::plus&lt;int&gt; iplus;</span><br><span class="line">    std::cout &lt;&lt; iplus(1, 2) &lt;&lt; std::endl;</span><br><span class="line">    std::vector&lt;int&gt; vec = &#123;1, 3, 4, 5, -1, 2, 3&#125;;</span><br><span class="line">    std::sort(vec.begin(), vec.end(), [](int ele1, int ele2)</span><br><span class="line">              &#123; return ele1 &gt; ele2; &#125;);</span><br><span class="line">    //使用可调用对象</span><br><span class="line">    std::sort(vec.begin(),vec.end(),std::greater&lt;int&gt;());</span><br><span class="line">    for (auto item : vec)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; item &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="六、适配器与分配器"><a href="#六、适配器与分配器" class="headerlink" title="六、适配器与分配器"></a>六、适配器与分配器</h2><ol>
<li><p>什么是容器适配器：“适配器是使一种事物的行为类似于另外一种事物行为的一种机制”。适配器对容器进行包装，使其表现出另外一种行为。例如：stack<int> 实现了栈的功能，内部默认使用deque<int>容器来存储数据。</int></int></p>
</li>
<li><p>STL的适配器有哪些：标准库提供了三种顺序容器适配器，没有关联型容器的适配器。分别是queue（队列），priority_queue（优先级队列），stack（栈）。</p>
</li>
<li>适配器的使用：</li>
</ol>
<ul>
<li>要使用适配器，首先需要引入对应的头文件<ul>
<li>要使用stack，                  需要#include<stack></stack></li>
<li>要使用queue或priority_queue，  需要#include<queue></queue></li>
</ul>
</li>
<li>适配器的初始化：<ul>
<li>普通的初始化方式：             stack<int>  stk。</int></li>
<li>覆盖默认容器类型的初始化方式： stack&lt;int, vector<int>&gt;    stk</int></li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    std::stack&lt;int&gt; iStack;</span><br><span class="line">    iStack.push(1);</span><br><span class="line">    iStack.push(2);</span><br><span class="line">    std::cout &lt;&lt; iStack.top() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::queue&lt;int&gt; iqueue;</span><br><span class="line">    iqueue.push(1);</span><br><span class="line">    iqueue.push(2);</span><br><span class="line">    std::cout &lt;&lt; iqueue.front() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>分配器提一下就可以了。在分配动态内存时，直接使用new，delete容易产生内存碎片化的问题，不同的分配器有不同的分配内存的方法，可以大幅提高程序对堆内存的使用效率，我们直接使用默认的分配器就可以了</li>
</ol>
<h2 id="附录：-STL各种容器的操作"><a href="#附录：-STL各种容器的操作" class="headerlink" title="附录： STL各种容器的操作"></a>附录： STL各种容器的操作</h2><h3 id="1-vector的各种函数"><a href="#1-vector的各种函数" class="headerlink" title="1. vector的各种函数"></a>1. vector的各种函数</h3><h4 id="1-构造函数"><a href="#1-构造函数" class="headerlink" title="1.构造函数"></a>1.构造函数</h4><ol>
<li>vector()：创建一个空的vector</li>
<li>vector(const std::allocator<t>&amp; al)：使用指定的分配器来分配内存。allocator就是一个内存分配器，vector已经指定了默认的分配器了，不需要我们去主动调用，以后设计allocator直接忽略就可以了，其实这个构造函数只不过是用指定的分配器去创建一个空的vector罢了。</t></li>
<li>vector(std::vector<t>&amp;&amp; right, const std::allocator<t>&amp; al)：就是移动构造函数，第二个参数表示我们指定分配器。</t></t></li>
<li>vector(const std::vector<t>&amp; vec, const std::alloctor<t>&amp; al)：就是复制构造函数，分配器可以自己指定，当然，一般来说，vector默认的分配器就够用了。</t></t></li>
<li>vector(std::initializer_list<t>&amp; initList, const std::allocator<t>&amp; al)：就是使用initializer_list来初    始化容器，第二个参数表示我们可以指定分配器。</t></t></li>
<li>vector(iter first, iter last, const std::allocator<t>&amp; al)：就是容器初始有迭代器[first, last)的内容（这里使用deque，list的迭代器也可以），第三个参数还是表示我们可以指定分配器。</t></li>
<li>vector(const size_t count, const std::alloctor<t>&amp; al)：创建一个vector，元素个数为count。元素均为默认值，如果是普通类型，则赋值为0。如果是类类型，则均使用默认构造函数进行初始化。</t></li>
<li>vector(const size_t count，const T&amp; t)：创建一个vector，元素个数为count，且值均为t。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    std::vector&lt;int&gt; ivec&#123;1, 2, 3, 4&#125;;</span><br><span class="line">    std::vector&lt;int&gt; ivec2(100); // 100个元素，每个元素都是0</span><br><span class="line">    std::vector&lt;int&gt; ivec3(100,5); // 100个元素，每个元素都是5</span><br><span class="line">    for (auto item : ivec2)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; item &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::deque&lt;int&gt; ideque&#123;1, 2, 3, 4, 4&#125;;</span><br><span class="line">    std::set&lt;int&gt; iset&#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-增加函数"><a href="#2-增加函数" class="headerlink" title="2. 增加函数"></a>2. 增加函数</h4><ol>
<li>void push_back(const T&amp; value)：向容器尾部增加一个元素value。</li>
<li>void push_back(T&amp;&amp; value)：向容器尾部增加一个元素value，这不过这次以右值引用的形式添加。</li>
<li>std::vector<t>::iterator insert(std::vector<t>::const_iterator&amp; where, std::initializer_list<t> initList)：在where迭代器指定的地方添加initList，返回值为指向新添加的第一个元素的迭代器，insert函数虽然有很多重载，但返回值是完全类似的，所以接下来insert函数的返回值就不介绍了。</t></t></t></li>
<li>std::vector<t>::iterator insert(std::vector<t>::const_iterator&amp; where, iter first, iter last)：将迭代器[first, last)添加到迭代器where指定的位置。</t></t></li>
<li>std::vector<t>::iterator insert(std::vector<t>::const_iterator&amp; where, size_t count, const int&amp; value)：在where处插入count个value。</t></t></li>
<li>std::vector<t>::iterator insert(std::vector<t>::const_iterator&amp; where, const T&amp; value)：在where处插入value。</t></t></li>
<li>std::vector<t>::iterator insert(std::vector<t>::const_iterator&amp; where, T&amp;&amp; value)：在where处插入value，只不过这次以右值引用的形式插入了。</t></t></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    std::vector&lt;int&gt; ivec2&#123;1, 2, 3, 4&#125;;</span><br><span class="line">    //追加函数</span><br><span class="line">    ivec2.push_back(10);</span><br><span class="line">    ivec2.push_back(20);</span><br><span class="line">    //插入函数</span><br><span class="line">    auto iter = ivec2.insert(++ivec2.cbegin(), 100); //返回值为插入的第一个元素迭代器，这儿返回第二个元素100</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; std::distance(ivec2.begin(), iter) &lt;&lt; std::endl; //返回1</span><br><span class="line">    for (auto item : ivec2)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; item &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    auto iter2 = ivec2.insert(++ivec2.cbegin(), &#123;1, 2, 3, 4, 5, 6&#125;); //添加一个初始化列表</span><br><span class="line"></span><br><span class="line">    auto iter2 = ivec2.insert(++ivec2.cbegin(), 3, 40); //添加3个40</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-删除函数"><a href="#3-删除函数" class="headerlink" title="3. 删除函数"></a>3. 删除函数</h4><ol>
<li>std::vector<t>::iterator erase(std::vector<t>::const_iterator where)：删除容器迭代器指向的元素。返回指向被删除元素后面的那个元素的迭代器。</t></t></li>
<li>iterator erase(iterator first, iterator last)：删除容器中[first, last)中的元素。返回指向被删除元素后面的那个元素的迭代器。</li>
<li>void pop_back()：删除容器中最后一个元素。</li>
<li>clear()：删除容器中所有元素。</li>
</ol>
<h4 id="4-遍历函数"><a href="#4-遍历函数" class="headerlink" title="4. 遍历函数"></a>4. 遍历函数</h4><ol>
<li>T&amp; at(const size_t pos)：返回pos位置元素的引用。</li>
<li>const T&amp; at(const size_t pos) const：at函数的常量版本。</li>
<li>T&amp; front()：返回首元素的引用。</li>
<li>const T&amp; front() const：front函数的常量版本。</li>
<li>T&amp; back()：返回尾元素的引用。</li>
<li>const T&amp; back() const：back函数的常量版本。</li>
<li>std::vector<t>::iterator begin()：返回指向容器第一个元素的迭代器。</t></li>
<li>std::vector<t>::const_iterator begin() const：begin函数的常量版本。</t></li>
<li>std::vector<t>::const_iterator cbegin() const：可以主动调用的begin函数的常量版本。</t></li>
<li>std::vector<t>::iterator end()：返回指向容器最后一个元素的下一个元数的迭代器。<br>end()函数也有两个常量版本，和begin类似，就不写了。</t></li>
<li>std::vector<t>::reverse_iterator rbegin()：反向迭代器，指向最后一个元素。<br>同样有两个常量版本。</t></li>
<li>reverse_iterator rend()：反向迭代器，指向第一个元素之前的元素。<br>同样有两个常量版本。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    std::vector&lt;int&gt; ivec2&#123;1, 2, 3, 4&#125;;</span><br><span class="line">    //遍历函数</span><br><span class="line">    auto item = ivec2.at(0);    // at</span><br><span class="line">    int &amp;item2 = ivec2.front(); //返回首个元素(返回的是引用)</span><br><span class="line">    item2 = 222;</span><br><span class="line">    int &amp;item3 = ivec2.back(); //返回最后一个元素(返回的是引用)</span><br><span class="line">    item3 = 222;</span><br><span class="line">    std::cout &lt;&lt; item &lt;&lt; std::endl;</span><br><span class="line">    for (auto item : ivec2)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; item &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // crbegin返回最后一个元素，crend返回第一个元素</span><br><span class="line">    for (auto iter = ivec2.crbegin(); iter != ivec2.crend(); iter++)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; (*iter) &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-判断函数"><a href="#5-判断函数" class="headerlink" title="5. 判断函数"></a>5. 判断函数</h4><ol>
<li>bool empty() const：判断容器是否为空，若未空，则返回true，否则返回false。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    std::vector&lt;int&gt; ivec2&#123;1, 2, 3, 4&#125;;</span><br><span class="line">    //判断函数</span><br><span class="line">    std::cout &lt;&lt; ivec2.empty() &lt;&lt; std::endl; //为空返回1,否则返回0</span><br><span class="line">    for (auto item : ivec2)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; item &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-大小函数"><a href="#6-大小函数" class="headerlink" title="6. 大小函数"></a>6. 大小函数</h4><ol>
<li>size_t size() const：返回当前容器中元素的个数。</li>
<li>size_t capacity() const：返回当前容器不扩张所能容纳的最大元素数量。</li>
<li>size_t max_size() const：返回当前机器可以存储的元素数量最大值。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    std::vector&lt;int&gt; ivec2&#123;1, 2, 3, 4&#125;;</span><br><span class="line">    //大小函数</span><br><span class="line">    std::cout &lt;&lt; ivec2.size() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; ivec2.capacity() &lt;&lt; std::endl;//不扩容的情况下，容量大小</span><br><span class="line">    std::cout &lt;&lt; ivec2.max_size() &lt;&lt; std::endl;//扩容的情况下，最大容量大小 4611686018427387903</span><br><span class="line">    for (auto item : ivec2)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; item &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="7-其它函数"><a href="#7-其它函数" class="headerlink" title="7. 其它函数"></a>7. 其它函数</h4><ol>
<li>void swap(std::vector<t> &amp; vec)：交换两个同类型容器的的数据。</t></li>
<li>void assign(int n, const T&amp; x)：将容器设置为n个x。</li>
<li>void assign(const_iterator first, const iterator last)：将当前容器的元素设置为[first, last)。<br>first,last都是迭代器，可以不是vector类型的迭代器，deque，list类型也可以。</li>
<li>void assign(const std::initialize_list<t> initList)：将容器元素设置为initialize_list的元素。</t></li>
<li>void resize(size_t newSize)：将容器的容量设置为newSIze。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    std::vector&lt;int&gt; ivec2&#123;1, 2, 3, 4&#125;;</span><br><span class="line">    std::vector&lt;int&gt; ivec3&#123;4, 5, 6, 7&#125;;</span><br><span class="line">    //交换函数</span><br><span class="line">    ivec2.swap(ivec3);</span><br><span class="line">    //重置函数</span><br><span class="line">    ivec2.assign(&#123;1,3,4,5,5,67&#125;);</span><br><span class="line">    ivec2.assign(ivec2.begin(),ivec2.begin()+2);</span><br><span class="line">    ivec2.assign(10,9);//设置10个元素，每个元素初始为9</span><br><span class="line">    //重新设置大小</span><br><span class="line">    ivec2.resize(20);</span><br><span class="line">    ivec2.resize(2);//只保留开始两个元素</span><br><span class="line">    for (auto item : ivec2)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; item &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-deque的各种函数："><a href="#2-deque的各种函数：" class="headerlink" title="2. deque的各种函数："></a>2. deque的各种函数：</h3><p>deque的各种函数与vector类似，我就不再重复一遍了。<br>这里只介绍vector不同的地方：</p>
<p>deque支持在容器前面插入删除，操作。也就是支持以下的三个函数</p>
<ul>
<li>void push_front(const T&amp; value）；</li>
<li>void push_front(T&amp;&amp; value)；</li>
<li>void pop_front()；</li>
</ul>
<h3 id="3-list的各种函数"><a href="#3-list的各种函数" class="headerlink" title="3. list的各种函数"></a>3. list的各种函数</h3><p>list和deque类似，只讲一下和deque不同的部分。list都用支持在前面，后面增加，删除。</p>
<p>list和deque在函数上的唯一区别就是不支持随机缩影，也就是不支持at函数。</p>
<h3 id="4-string的各种函数"><a href="#4-string的各种函数" class="headerlink" title="4. string的各种函数"></a>4. string的各种函数</h3><p>string虽然也是顺序容器，但因为本质是对字符串的封装，所以和其它容器在用法上有较大区别。</p>
<ol>
<li>获取封装字符串的函数。</li>
</ol>
<ul>
<li>const char* c_str() const：返回string对象内部的函数的指针。注意，c_str()函数返回的直接就是string对象内部的指针，也就是说string对象指向的对象发生了改变，返回的对象也会发生改变的。</li>
<li>const char* data()const：返回string对象内部的函数指针。和c_str()函数的区别就是返回的字符串后面没有’\0’。</li>
<li>size_t copy(char* const ptr, size_t count, const size_t off) const：</li>
</ul>
<p>讲string对象的一部分复制到ptr数组中。<br>ptr表示复制到哪个数组。<br>count表示复制string对象的几个字符<br>off表示从string的哪个字符开始复制。</p>
<ol start="2">
<li>字符串比较函数。<br>compare函数：这个函数重载比较多，用的时候在vs中查看一下就可以了。可以用string对象的任意部分与另一个字符串进行比较，</li>
</ol>
<p>其它函数就和vector类似了，同样支持随机选取，支持容器末尾插入。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;deque&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include&lt;list&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    const char *str=&quot;hello world&quot;;</span><br><span class="line">    std::string st1(&quot;1111&quot;);</span><br><span class="line">    std::cout&lt;&lt;st1.c_str()&lt;&lt;std::endl;//返回c语言类型的const char *</span><br><span class="line">    std::cout&lt;&lt;st1.data()&lt;&lt;std::endl;//结尾无\0</span><br><span class="line">    st1.compare(&quot;!22222&quot;);//字符串比较</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-forward-list"><a href="#5-forward-list" class="headerlink" title="5. forward_list:"></a>5. forward_list:</h3><p>和list差不多，只不过是没有size()函数，没有push_back和pop_back函数。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">CinKate</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://renxingkai.github.io/2022/08/29/cpp-stl/">http://renxingkai.github.io/2022/08/29/cpp-stl/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a></div><div class="social-share pull-right" data-disabled="google,facebook"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2022/11/27/pert/"><i class="fa fa-chevron-left">  </i><span>PERT PRE-TRAINING BERT WITH PERMUTED LANGUAGE MODEL 阅读笔记</span></a></div><div class="next-post pull-right"><a href="/2022/08/22/cpp-ptr/"><span>C++新特性系列三：智能指针</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(http://p17.qhimg.com/d/_open360/fengjing0403/21.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2022 By CinKate</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://renxingkai.github.io">blog</a>!</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script src="/js/katex.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>